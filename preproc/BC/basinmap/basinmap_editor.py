"""
This files contains functions meant to generate GEOCLIM land-to-ocean routing
map (drainage basin map) from climate model outputs, and oceanic-grid basin mask
generated by "../BC_generator.py".
It does so by finding the closest oceanic point, and allows the user to
interactively edit the generated map. The interactive edition uses the package
"netcdf_visualization" (https://github.com/piermafrost/netcdf_visualization)

This interactive edition is almost always necessary for two reasons:
  1. The land routing must be towards oceanic epicontinental boxes of GEOCLIM.
     However, on the oceanic-grid basin mask, the grid cells at the edges of
     continents can often belong to open-ocean boxes (not epicontinental), so,
     by finding the closest oceanic point, the algorithm will route land fluxes
     toward both open-ocean and epicontinental boxes. This need to be manually
     corrected.
  2. The routing algorithm cannot use the information about pre-defined river
     basins (in the climate model), since there is no generic way to indicate
     which river flows in which ocean. Therefore, in the given map of predefined
     river basins (with the help of river outlets map) the user must "hand-pick"
     each basin and edit the routing map (this can be easily done with the
     selecting option "click on value" from the netCDF editor. The selected
     area is kept when switching from one variable to another in the editor).

To see an example of use of the script's main function, try:
`python basinmap_editor.py`
"""


import numpy as np
import netCDF4 as nc
from matplotlib import pyplot as plt
from geographic_computation import get_closest_B_from_A
try:
    from netcdf_visualization import shaedit
    ENABLED_EDITOR = True
except (ImportError, ModuleNotFoundError) as err:
    print('WARNING: cannot use interactive netCDF editor')
    print(err)
    ENABLED_EDITOR = False



# Local functions
# ===============

def _get_var(varname, list_of_dset, raise_error=True):
    """
    Get a variable 'varname' from of list of netCDF4.Dataset 'list_of_dset'
    """
    for ds in list_of_dset:
        try:
            return ds.variables[varname]
        except KeyError:
            pass

    if raise_error:
        raise ValueError('Could not find variable "{:}" in given list of datasets'.format(varname))


def grid_edge(*args):
    """
    Compute, for any number of 1D or 2D input arrays, their "edge" arrays.
    E.g.,
      x = [10., 11., 13.]  -->  grid_edge(x) =  [9.5, 10.5, 12., 14.]
    """

    outargs = []

    for x in args:

        if x.ndim == 1:
            # --------------------
            # Compute 1D grid edge
            # --------------------
            xe = np.zeros((x.size+1), x.dtype)
            #
            xe[1:-1] = (x[:-1] + x[1:]) / 2
            #
            xe[0]  = 2*x[0] - xe[1]
            xe[-1] = 2*x[-1] - xe[-2]

        elif x.ndim == 2:
            # --------------------
            # Compute 2D grid edge
            # --------------------
            xe = np.zeros([s+1 for s in x.shape], x.dtype)
            #
            xe[1:-1,1:-1] = (x[:-1,:-1] + x[1:,:-1] + x[:-1,1:] + x[1:,1:])/4
            #
            xe[0,1:-1]  = (3*x[0,:-1]  - x[1,:-1]  + 3*x[0,1:]  - x[1,1:])/4
            xe[1:-1,0]  = (3*x[:-1,0]  - x[:-1,1]  + 3*x[1:,0]  - x[1:,1])/4
            xe[-1,1:-1] = (3*x[-1,:-1] - x[-2,:-1] + 3*x[-1,1:] - x[-2,1:])/4
            xe[1:-1,-1] = (3*x[:-1,-1] - x[:-1,-2] + 3*x[1:,-1] - x[1:,-2])/4
            #
            xe[0,0]   = (7*x[0,0]   - x[0,1]   - x[1,0]   - x[1,1])/4
            xe[-1,0]  = (7*x[-1,0]  - x[-1,1]  - x[-2,0]  - x[-2,1])/4
            xe[0,-1]  = (7*x[0,-1]  - x[0,-2]  - x[1,-1]  - x[1,-2])/4
            xe[-1,-1] = (7*x[-1,-1] - x[-1,-2] - x[-2,-1] - x[-2,-2])/4

        else:
            raise NotImplementedError('Can only compute edge array of 1D or 2D grid')

        outargs.append(xe)

    return tuple(outargs)




#####################
##  -------------  ##
##  MAIN FUNCTION  ##
##  -------------  ##
#####################

def make_routing_map(input_files, lon:str, lat:str, lsm:str,
                     oce_basin_mask, oce_input_files=None, ocelon=None, ocelat=None,
                     watershed_map=None, outlets_map=None,
                     output_file='GEOCLIM_land2ocean_routing.nc', output_var='geoclim_routing_map',
                     interactive_edition=True, check_plot=True, invert_axis=None):
    """
    This function computes the map of continental drainage basins correponding
    to the ocean basins, indicated by the basin maks variable, defined on the
    oceanic grid, and normally generated by the script "../BC_generator.py".

    In a first time, the drainage map is generated by determining, for each
    continental point, wich is THE CLOSEST OCEANIC POINT, and assigning its
    oceanic basin ID (indicated by the ocean basin mask variable) to the
    continental point.
    Therefore, the needed inputs are the continental fraction (land-sea mask),
    the oceanic basin mask, and the coordinates of continental and oceanic grids

    In a second time, the interactive editor (from "netcdf_visualization"
    package) is launched, for the user to manually edit the generated drainge
    map, with the help of the (optional): map of continental watersheds (river
    basins) in the input data from climate model, map of river outlets, ...
    This step can be skipped by speciying "interactive_edition=False".

    The generated drainage map (or routing map) is saved in a netCDF file
    created by this function.

    MANDATORY INPUT ARGUMENTS:

        input_files: string, or list of string
            File name (path), or list of file name. Expect netCDF files. The
            function will try and get all the input variables from these files
            (in the order of the list, until the variable is found).

        lon: string
            Name of the "longitude" variable (of continental grid) in netCDF
            inputs.

        lat: string
            Name of the "latitude" variable (of continental grid) in netCDF
            inputs.

        lsm: string
            Name of the "land-sea mask", or "continental fraction" variable in
            the netCDF inputs.

        oce_basin_mask: string, numpy-array, or netCDF4.Variable
            Two possibilities:
            - netCDF file name (path) containing the 3D basin mask on the
              oceanic grid (expect a file generated by "../BC_generator.py").
            - the basin mask array itself, AT SURFACE LAYER (hence 2D, not 3D).

    OPTIONAL INPUT ARGUMENTS:

        oce_input_files: string, list of string, or None (default)
            File name (path), or list of file name (netCDF file). If the oceanic
            variables are stored in different files, and they are name conflict
            (e.g., same variable name "lon" for different continental and
            oceanic grid), the oceanic inputs will be loaded from these files.

        ocelon: string, or None (default)
            Name of the "longitude" variable (of oceanic grid) in netCDF inputs.
            If not provided, it is assumed to be the same than continental grid.

        ocelat: string, or None (default)
            Name of the "latitude" variable (of oceanic grid) in netCDF inputs.
            If not provided, it is assumed to be the same than continental grid.

        watershed_map: string, or None (default)
            Name of the variable indicating the map of watersheds (river basins)
            in the continental grid, as defined in the climate model.
            Optional, only used for plotting, and editing GEOCLIM routing map.

        outlets_map: string, or None (default)
            Name of the variable indicating the map of river outlets in the
            continental grid, as defined in the climate model.
            Optional, only used for plotting, and editing GEOCLIM routing map.

        output_file: string
            Name of the output file created by the function, containing the
            GEOCLIM land-to-ocean routing map.

        output_var: string
            Name of the land-to-ocean routing map in the created output file.

        interactive_edition: bool, default: True
            Whether or not launch interactive edition of the generated routing
            map, with "shaedit" function of "netcdf_visualization" package.

        check_plot: bool, default: True
            Whether or not plot maps of the input data (ocean basin mask,
            watersheds, etc.) in addition to the potential interactive edition.

        invert_axis: string, or None (default)
            Axis to flip when showing continental data with the interactive
            editor (data is plotted in "indices" coordinates, not lon-la axis).

    Example of use can be found at the end of the current file.
    """


    # =============== #
    # Load input data #
    # =============== #

    # Dataset
    if isinstance(input_files, str):
        ncinputs = [nc.Dataset(input_files)]
    else:
        ncinputs = [nc.Dataset(fname) for fname in input_files]

    # Ocean inputs dataset
    if oce_input_files is None:
        ocencinputs = []
    elif isinstance(oce_input_files, str):
        ocencinputs = [nc.Dataset(oce_input_files)]
    else:
        ocencinputs = [nc.Dataset(fname) for fname in oce_input_files]

    # Variables
    lon    = _get_var(lon,    ncinputs)
    lat    = _get_var(lat,    ncinputs)
    lsm    = _get_var(lsm,    ncinputs)
    ocelon = lon if ocelon is None else _get_var(ocelon, ocencinputs+ncinputs)
    ocelat = lat if ocelat is None else _get_var(ocelat, ocencinputs+ncinputs)
    # "optional" variables
    watershed_map = _get_var(watershed_map, ncinputs, raise_error=False)
    outlets_map   = _get_var(outlets_map,   ncinputs, raise_error=False)

    # Key variable: oceanic basin mask
    if isinstance(oce_basin_mask, np.ndarray) or isinstance(oce_basin_mask, nc.Variable):
        # => expect the 2D basin mask
        if oce_basin_mask.ndim != 2: raise ValueError('ocean basin mask array must be rank-2')
        ocebas = oce_basin_mask[:,:]
    elif isinstance(oce_basin_mask, str):
        # => expect a standard "basins_masks.nc" file created by BC_generator
        f = nc.Dataset(oce_basin_mask)
        i0 = 0 if f['z'].positive=='down' else -1
        ocebas = f['mask'][i0,:,:]
        f.close()


    # ====================== #
    # Check data consistency #
    # ====================== #

    if lsm.ndim != 2:
        raise ValueError('"lsm" must be rank-2.')

    if lon.ndim == 1 and lat.ndim == 1:
        if lsm.shape != (lat.size, lon.size):
            raise ValueError('Shape of "lsm" array inconsistent with "lon" and "lat" axis.')
    elif lon.ndim == 2 and lat.ndim == 2:
        if lon.shape != lat.shape or lon.shape != lsm.shape:
            raise ValueError('2D arrays "lon", "lat" and "lsm" must have the same shape.')

    if ocelon.ndim == 1 and ocelat.ndim == 1:
        if ocebas.shape != (ocelat.size, ocelon.size):
            raise ValueError('Shape of "ocean_basin_mask" array inconsistent with "ocelon" and "ocelat" axis.')
    elif ocelon.ndim == 2 and ocelat.ndim == 2:
        if ocelon.shape != ocelat.shape or ocelon.shape != ocebas.shape:
            raise ValueError('2D arrays "ocelon", "ocelat" and "ocean_basin_mask" must have the same shape.')

    if not np.ma.is_masked(ocebas):
        raise ValueError('Expect ocean basin mask to be a masked array with at least 1 masked point (= continental points)')


    if check_plot:

        # ======================== #
        # Compute edge coordinates #
        # ======================== #

        # Oceanic coordinates
        # -------------------
        ocelon_e, ocelat_e = grid_edge(ocelon[:], ocelat[:])

        # Land coordinates
        # ----------------
        lon_e, lat_e = grid_edge(lon[:], lat[:])


        # ==== #
        # PLOT #
        # ==== #

        fig, ax = plt.subplots()
        fig.suptitle('Map of oceanic basin on oceanic grid')
        pid = ax.pcolormesh(ocelon_e, ocelat_e, ocebas, cmap='turbo')
        ax.set_xlabel('longitude (°E)')
        ax.set_ylabel('latitude (°N)')
        plt.colorbar(pid)

        if watershed_map is not None:
            fig, ax = plt.subplots()
            fig.suptitle('Map of continental river basins')
            ax.pcolormesh(lon_e, lat_e, (watershed_map[:,:]==0).astype('int16'), vmin=0, vmax=2, cmap='Greys')
            pid = ax.pcolormesh(lon_e, lat_e, np.ma.masked_values(watershed_map[:,:], 0), cmap='turbo')
            ax.set_xlabel('longitude (°E)')
            ax.set_ylabel('latitude (°N)')
            plt.colorbar(pid)
            if outlets_map is not None:
                fig.suptitle('Map of continental river basins\nand river outlets')
                iriv, jriv = np.nonzero(outlets_map[:,:]>0)
                ax.plot(lon[jriv], lat[iriv], 'x', color='black', linewidth=3)


    # <><><><><><><><><><><><><><><><><><><><><><><><> #
    # Compute routing map as "closest coastal points"  #
    # <><><><><><><><><><><><><><><><><><><><><><><><> #

    # ocean mask
    #   - only keep coastal "ocebas" points (i.e., points that are neighbourg of masked points)
    msk = np.zeros(ocebas.shape, dtype=bool)
    n, m = msk.shape[0]-1, msk.shape[1]-1
    for di, dj in zip([-1,0,1,1,1,0,-1,-1], [-1,-1,-1,0,1,1,1,0]): # "8-neighbours" loop
        msk[1:n,1:m] |= ocebas.mask[1+di:n+di,1+dj:m+dj]

    msk[1:n,1:m] = ~msk[1:n,1:m] # => masked points = True, + keep the edges unmasked
    ocebas = np.ma.masked_where(msk, ocebas)

    #  land mask
    land_mask = (lsm[:,:]>0)
    if hasattr(land_mask, 'mask'):
        land_mask = np.logical_and(land_mask.data, ~land_mask.mask)

    # Initialization of drainage map (fill-value)
    drainage_map = -np.ones(lsm.shape, dtype=ocebas.dtype)
    drainage_map = np.ma.masked_where(~land_mask, drainage_map, copy=True)

    # For each land point, get closet unmasked coastal oceanic point
    icls, jcls = get_closest_B_from_A(lon[:], lat[:], ocelon[:], ocelat[:], mask_A=land_mask, mask_B=~ocebas.mask)
    # Attribute, to each land point, the value (ID) of the closest oceanic point found 
    drainage_map[land_mask] = ocebas[icls[land_mask], jcls[land_mask]]

    # Check-plot
    # ==========
    if check_plot:
        fig, ax = plt.subplots()
        fig.suptitle('Continental watersheds (going to closest oceanic point)')
        pid = ax.pcolormesh(lon_e, lat_e, drainage_map, cmap='turbo')
        ax.set_xlabel('longitude (°E)')
        ax.set_ylabel('latitude (°N)')
        plt.colorbar(pid)


    # ======================================= #
    # Create output file and save routing map #
    # ======================================= #

    # Open input and output files
    fout = nc.Dataset(output_file, mode='w', data_model='NETCDF3_CLASSIC')
    fout.setncattr('title', 'routing map from 2D continental grid to GEOCLIM oceanic basins')

    # Copy dimensions
    for dim in lsm.get_dims():
        fout.createDimension(dim.name, dim.size)
        try:
            dimvar = dim.group().variables[dim.name]
            fout.createVariable(dim.name, datatype=dimvar.datatype, dimensions=(dim.name,))
            # copy attributes
            for att in dimvar.ncattrs():
                if att not in ['missing_value', 'fill_value', '_FillValue']:
                    fout.variables[dim.name].setncattr(att, dimvar.getncattr(att))
            #
            # put dimension variable
            fout.variables[dim.name][:] = dimvar[:]

        except KeyError as err:
            print('Cannot put dimension variable "{:}" in output file:'.format(dim.name), err)

    # Create and put variable
    fout.createVariable(output_var, datatype=drainage_map.dtype, dimensions=lsm.dimensions, fill_value=-1)
    fout.variables[output_var].setncattr('standard_name', 'routing_map')
    fout.variables[output_var].setncattr('long_name', 'IDs of GEOCLIM oceanic boxes')
    fout.variables[output_var].setncattr('units', '-')
    fout.variables[output_var][:,:] = drainage_map


    # ================================== #
    # Interactive edition of routing map #
    # ================================== #

    if interactive_edition and ENABLED_EDITOR:

        list_var = []
        for var in [lsm, watershed_map, fout.variables[output_var]]:
            if var is not None:
                list_var.append(var)

        shaedit(*tuple(list_var), cmap='turbo', invert_axis=invert_axis, show=True)

    fout.close()

    if check_plot: plt.show()



#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#####################
# TRY MAIN FUNCTION #
#####################

if __name__ == '__main__':

    # Example for IPSL PI control with Atlantic and Pacific
    make_routing_map(['../../../INPUT/IPSL/CTRL_CM5A2/piControl_sechiba_basinmap.nc',
                      '../../../INPUT/IPSL/CTRL_CM5A2/piControl_SE_2750_2849_1Y_sechiba.nc'],
                     lon='lon', lat='lat', lsm='Contfrac',
                     oce_basin_mask='../../../INPUT/COMBINE/IPSL-PI_AtlPac/basins_masks.nc',
                     oce_input_files='../../../INPUT/IPSL/coordinates.nc', ocelon='nav_lon', ocelat='nav_lat',
                     watershed_map='basinmap', outlets_map='nbrivers',
                     output_file='template_GEOCLIM_land2ocean_routing.nc',
                     invert_axis='y')

    ## Example for FOAM
    ##   WARNING: "../test_FOAM/" files are NOT on current Github repository,
    ##   but can be created with "../examples_oceanic_input.py" ('FOAM' case)
    #make_routing_map('../../../INPUT/FOAM/PIctrl_cpld/lsm.nc',
    #                 lon='lon', lat='lat', lsm='lsm',
    #                 oce_basin_mask='../test_FOAM/basins_masks.nc',
    #                 output_file='test_FOAM_land2ocean_routing.nc')

    ## Example for IPSL 90Ma (similarly, files not on GitHub repository)
    #make_routing_map(['../../../INPUT/IPSL/90Ma_Laugie/other/basinmap_90Ma-ORB7a-2X.nc',
    #                  '../../../INPUT/IPSL/90Ma_Laugie/2X/Orb1/CPL-90Ma-ORB1-2X_SE_6950_7049_1Y_sechiba.nc',
    #                  '../../../INPUT/IPSL/90Ma_Laugie/grid/PALEORCA2.90MaCorrected_grid.nc'],
    #                 lon='lon', lat='lat', lsm='Contfrac',
    #                 oce_basin_mask='../../../INPUT/COMBINE/IPSL-90Ma-3bas-Arct3/basins_masks.nc',
    #                 ocelon='nav_lon', ocelat='nav_lat',
    #                 watershed_map='basinmap', outlets_map='nbrivers',
    #                 output_file='test_90Ma_land2ocean_routing.nc',
    #                 invert_axis='y')
    

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

